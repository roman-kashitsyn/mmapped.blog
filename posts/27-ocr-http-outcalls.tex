\documentclass{article}

\title{OCR vs HTTPS outcalls}
\subtitle{TODO}
\date{2024-05-01}
\modified{2024-05-01}
\keyword{ic}

\begin{document}
\section*

The more I learn about the \href{https://chain.link/}{Chainlink platform}, the more parallels I see between Chainlink's systems and the \href{https://internetcomputer.org/}{Internet Computer} (\sc{ic}) network I helped design and implement.
Both projects aim to provide a solid platform for \href{https://blog.chain.link/what-is-trust-minimization/}{trust-minimized computation}, but they take different paths toward that goal.

One of the limitations of blockchains is their self-contained nature.
They authenticate the data they store and the transaction history, but can't prove any facts about the external world.
This problem is commonly called the \href{https://chain.link/education-hub/oracle-problem}{oracle problem}.
Oracles are services that bring external data, such as price feeds and weather conditions, into a blockchain.

The Chainlink network and \sc{ic} solve the Oracle problem by providing byzantine fault-tolerant protocols.
Chainlinks relies on the \href{/posts/24-ocr.html}{Off-chain reporting protocol} (\sc{ocr}), while \sc{ic} provides the \href{https://internetcomputer.org/docs/current/references/https-outcalls-how-it-works}{\sc{https} outcalls} feature.
This article explores the pros and cons of each approach.

\section{https-outcalls}{HTTPS outcalls in a nutshell}

Smart contracts on the \sc{ic} network can initiate \sc{https} requests to external services.

First, the canister sends a message to the management canister that includes the \sc{https} request payload and the \href{https://internetcomputer.org/docs/current/references/https-outcalls-how-it-works#transformation-function}{transform callback function}.
The management canister includes this request in a dedicated queue in the node's replicated state.

A background process independent from the replicated state machine called \em{adapter} periodically inspects the request queue and executes requests from the queue.
Each replica has an independent instance of the adapter process.

\begin{figure}[grayscale-diagram,medium-size]
\includegraphics{/images/27-observe-data-source.svg}
\end{figure}

If the original canister specified the transform callback, the adapter invokes the callback on the canister as a query.
The callback accepts the raw \sc{http} response and returns its canonicalized version.
One universal use case for transform callbacks is stripping the response headers since they can contain information unique to the response, such as timestamps, that can make it impossible to reach a consensus on the response.

\begin{figure}[grayscale-diagram,medium-size]
\includegraphics{/images/27-transform.svg}
\end{figure}

The adapter passes the transformed response to the consensus algorithm, and the nodes exchange their observation shares.

\begin{figure}[grayscale-diagram,medium-size]
\includegraphics{/images/27-consensus-shares-transformed.svg}
\end{figure}

If enough replicas agree on the response, the system includes the response in the block.
The state machine delivers the response to the management canister, which forwards it to the originator.

\begin{figure}[grayscale-diagram,medium-size]
\includegraphics{/images/27-outcall-response-transformed.svg}
\end{figure}

\section{https-outcalls-as-ocr}{HTTPS outcalls as OCR}

It turns out, the \sc{https} outcalls implement a special case of the \sc{ocr}'s \href{/posts/24-ocr.html#report-generation}{report generation protocol}, where participants are \sc{ic} nodes.
The \sc{ocr} protocol defines three stages:
\begin{enumerate}
    \item The \em{query} stage is implicit: instead of the protocol leader initiating the query, the canister triggers a query by using the system interface.
    \item In the \em{observation} stage, each node executes an \sc{https} request and filters it through the calling canister's transformation function.
    The transformation result is the observation.
    \item The \em{report} stage is hard-coded in the \sc{ic} consensus protocol.
    If \math{2f + 1} observations have the same contents, this value becomes the report.
\end{enumerate}

To make \sc{https} outcalls as general as the full report generation protocol, we must make the report stage customizable.
The \sc{ic} consensus algorithm must allow the canister to observe all response versions and distill them into a single report.

\begin{figure}[grayscale-diagram,medium-size]
\includegraphics{/images/27-aggregate.svg}
\end{figure}

Then, the algorithm should reach a consensus on the aggregated report and deliver it to the canister.

\begin{figure}[grayscale-diagram,medium-size]
\includegraphics{/images/27-consensus-shares-aggregated.svg}
\end{figure}

This design requires adding another callback with the following signature to the \sc{https} outcalls flow:

\label{aggregate-func}
\begin{code}[candid]
\em{// Aggregates responses from multiple nodes into a canonical response.}
type AggregateFunc = func(record {
    responses : vec http_request_result;
    context : blob
}) -> (http_request_result) query;
\end{code}

This interface poses a challenge: how can the aggregation function know which responses it can trust?
The usual approach for numeric observations is to sort them and pick the median. 
Since there are at most \math{f} Byzantine nodes, and the \code{responses} vector contains at least \math{2f + 1} elements, only the top and bottom \math{f} responses can skew the observation significantly.

If there are more than \math{2f + 1} responses, the aggregation function can make a better choice if it knows the value of \math{f}.
Thus, the \href{https://internetcomputer.org/docs/current/references/ic-interface-spec/#system-api}{system \sc{api}} might provide a function to obtain the maximum number of faulty nodes in a subnet to improve the user experience:

\begin{code}
ic0.max_faulty_nodes : () -> (i32);
\end{code}

This design significantly restricts the \sc{http} response size.
Since the vector of responses might contain 34 entries on large subnets, and the callback input argument must fit in the two-megabyte limit, the size of each response must not exceed 58 kilobytes.
Luckily, thatâ€™s enough for many essential use cases, such as observing a frequently updating price feed or the latest block number of a blockchain with a high block rate.

Custom aggregation function is a powerful feature when considered in isolation.
But it also opens a door for another exciting use case: sending requests to multiple destinations in one call.
Most applications are interested in processing responses from multiple independent sources, not comparing a dozen responses from the same website.

For example, if you integrate with the Ethereum network using \sc{json rpc}, you might want to send identical requests to multiple independent node providers.
With the current implementation of \sc{https} outcalls, you must initiate a separate \sc{http} request for each provider.
We can let each node request a different resource, run the responses through different transformation functions, and unify the results using the aggregation function, using a fraction of the resources we would require if we did one call at a time.

\begin{code}[candid]
type mutli_http_request_arg = record {
    \em{// The list of requests to send.}
    \em{// The system transforms each request independently.}
    requests: vec http_request_args;
    \em{// The aggregation function to combine the results.}
    aggregate: opt \href{#aggregate-func}{AggregateFunc};
};

service ic : {
    \em{// \ldots}
    multi_http_request : (multi_http_request_args) -> (http_request_result);
};
\end{code}

\section{price-feeds}{Use-case: price feeds}

One of the most popular use cases for oracles is delivering price feeds to power DeFi applications.
Unsurprisingly, the \href{https://internetcomputer.org/docs/current/developer-docs/defi/exchange-rate-canister}{exchange rate canister} was one of the first users of the \sc{https} outcalls feature.
In this section, we'll walk through the hypothetical implementation of a price feed canister using the \sc{ocr}-inspired extension of the \sc{https} outcalls feature from the previous section.

\begin{code}[rust]
use ic_cdk::api::management_canister::http_request::{
    http_request, CanisterHttpRequestArgument, HttpHeader, HttpMethod, HttpResponse, TransformArgs,
    TransformContext,
};

#[ic_cdk::update]
async fn observe_icp_price() -> f64 {
    let request = HttpRequest {
        url: "https://api.example-exchange.com/price-feed?pair=ICP-USD".to_string(),
        method: HttpMethod::GET,
        headers: vec![],
        transform: Some(TransformContext::new())
        body: None,
    };
    let response = http_request(request);
    let response = aggregate_price_feed(response);
    ic0.print(response);
}

#[ic_cdk::query]
fn transform(args: TransformArgs) -> HttpResponse {
    let mut response = args.response;
    response.headers.clear();
    response
}
\end{code}

\section{conclusion}{Conclusion}

\end{document}
\documentclass{article}

\title{Box combinators}
\subtitle{The most visual way to print a table.}
\date{2025-05-31}
\modified{2025-05-31}
\keyword{programming}

\begin{document}

\section*

\epigraph{
  A combinator is a function which builds program fragments from program fragments.
}{John Hughes, ``\href{https://www.sciencedirect.com/science/article/pii/S0167642399000234}{Generalising monads to arrows}''}

In functional programming,
\emph{combinator libraries} refer to a design style that emphasizes bottom-up program construction.
Such libraries define a few core data types
and provide \emph{constructors}---functions that create initial objects---%
and \emph{combinators}---functions that build larger objects from smaller pieces.

Combinators enable the programmer to use intuitive visual and spatial reasoning
that's vastly more powerful than linear language processing.
As a result, solving problems with combinators feels like playing with \textsc{lego} pieces, not like writing an essay.

This article describes a combinator library that deals with two-dimensional blocks of \textsc{ascii} characters.
I'll use \href{https://ocaml.org/}{OCaml} to demonstrate the idea\sidenote{sn-functional-language}{Functional languages are a perfect medium for combinator libraries.},
but you won't have trouble translating it to any modern language.
Box combinators are my go-to tool when I need to visualize data programmatically for debugging or exploration.

\section{text-boxes}{Text boxes}

I stumbled on the idea of box combinators around 2012 while reading chapter 10 of ``\href{https://www.goodreads.com/book/show/5680904-programming-in-scala}{Programming in Scala}'', 2nd edition.
The chapter demonstrates how to use Scala's object-oriented features to build a module for rendering rectangular text boxes (the authors called them \emph{elements}).
This section describes the underlying idea without the object-oriented fluff.

The primary type in our library is the \emph{box}: a two-dimensional array of \textsc{ascii} characters\sidenote{sn-ascii}{
  Single-byte characters aren't a fundamental restriction;'
  we could also arrange Unicode glyphs in a grid.
}.
Following OCaml's naming conventions, we place the code in the \code{box.ml} file and call the box type \code{t}, so its fully-qualified name is \code{Box.t}.
A box has a \href{#ref-height}{\code{height}} (the number of rows in the array) and a \href{#ref-width}{\code{width}} (the number of columns).

\begin{code}[ocaml]
type t = string array

let height b = Array.length b\label{ref-height}

let width b = if Array.length b == 0 then 0 else String.length b.(0)\label{ref-width}

\emph{(** Returns the box height and width. *)}
let dimensions b = height b, width b

\emph{(** Prints box b to the standard output. *)}
let print_box b = Array.iter print_endline b
\end{code}

We then define basic constructors:
\href{#ref-of-string}{\code{of_string}} wraps a string into a unit-height grid\sidenote{sn-multiline}{
  Handling multiline strings is left as an exercise for the reader.
} and \href{#ref-fill}{\code{fill}} fills a box of specified dimensions with a character.
An \href{#ref-empty}{\code{empty}} box has zero dimensions and acts as a neutral element; combining it with other boxes has no effect.

\begin{code}[text,center]
                            +-------------+
of_string "Hello, World!" = |Hello, World!|
                            +-------------+

               +----+
               |aaaa|
fill 'a' 3 4 = |aaaa|
               |aaaa|
               +----+

empty = ++
        ++
\end{code}

\begin{figure}
\marginnote{mn-box-constructors}{
  Box constructors create primitive boxes.
}
\begin{code}[ocaml]
\emph{(** Creates a box large enough to hold string s. *)}
let of_string s = [| s |]\label{ref-of-string}

\emph{(** Creates an h\times w box filled with character c. *)}
let fill c h w = Array.make h (String.make w c)\label{ref-fill}

\emph{(** Creates a 1\times 1 box containing character c. *)}
let of_char c = fill c 1 1

\emph{(** Creates an h\times w box filled with spaces. *)}
let space h w = fill ' ' h w

\emph{(** An empty box. *)}
let empty = space 0 0\label{ref-empty}
\end{code}
\end{figure}

We can glue two boxes in at least two ways:
by stacking them horizontally (placing the first box \href{#ref-beside}{\code{beside}} the second)
or vertically (placing the first box \href{#ref-above}{\code{above}} the second).

\begin{code}[text,center]
+--+        +--+   +----+
|aa|        |bb|   |aabb|
|aa| beside |bb| = |aabb|
|aa|        |bb|   |aabb|
+--+        +--+   +----+

                    +--+
+--+         +--+   |aa|
|aa|         |bb|   |aa|
|aa|  above  |bb| = |aa|
|aa|         |bb|   |bb|
+--+         +--+   |bb|
                    |bb|
                    +--+
\end{code}

For the composite box to have well-defined height and width, the arguments must have compatible dimensions:
vertically stacked boxes must have the same width, and horizontally stacked boxes must have the same height.

We solve this issue by padding the smaller box with extra space:
we \href{#ref-widen}{\code{widen}} it for vertical composition
and \href{#ref-heighten}{\code{heighten}} it for horizontal composition.
We can add the padding before, after, or around the smaller box.
Since none of the options is inherently superior, we provide all three, using central alignment as the default.

\begin{code}[text,center]
+---+              +----+
|aaa|        +-+   |aaa |
|aaa| beside |b| = |aaab|
|aaa|        +-+   |aaa |
+---+              +----+

+---+         +-+   +---+
|aaa|  above  |b| = |aaa|
+---+         +-+   | b |
                    +---+
\end{code}


\begin{figure}
\marginnote{mn-box-combinators}{
  Box combinators \href{#ref-beside}{\code{beside}} and \href{#ref-above}{\code{above}} stack boxes horizontally and vertically.
  Note that these combinators are mutually recursive.
}
\begin{code}[ocaml]
\emph{(** The vertical alignment type. *)}
type vertical   = [ `Top  | `Center | `Bottom ]

\emph{(** The horizontal alignment type. *)}
type horizontal = [ `Left | `Center | `Right  ]

\emph{(** Stack box l to the left of box r. *)}
\b{let rec} beside ?(align:vertical = `Center) l r =\label{ref-beside}
    if width l == 0 then r else if width r == 0 then l
    else let hl = heighten ~align l (height r) in
         let hr = heighten ~align r (height l) in
         Array.map2 String.cat hl hr

\emph{(** Stack box t above of box b. *)}
\b{and} above ?(align:horizontal = `Center) t b =\label{ref-above}
    if height t == 0 then b else if height b == 0 then t
    else let wt = widen ~align t (width b) in
         let wb = widen ~align b (width t) in
         Array.append wt wb

\emph{(** Makes box b at least w units wide. *)}
\b{and} widen ?(align:horizontal = `Center) b w =\label{ref-widen}
    if width b >= w then b
    else let bh, bw = height b, width b in
         let pw = w - bw in
         match align with
         | `Left   -> beside b (space bh pw)
         | `Right  -> beside (space bh pw) b
         | `Center -> hconcat
                      [| space bh (pw/2); b; space bh (pw - pw/2) |]

\emph{(** Makes box b at least h units high. *)}
\b{and} heighten ?(align:vertical = `Center) b h =\label{ref-heighten}
    if height b >= h then b
    else let bh, bw = height b, width b in
         let ph = h - bh in
         match align with
         | `Top    -> above b (space ph bw)
         | `Bottom -> above (space ph bw) b
         | `Center -> vconcat [| space (ph/2) bw
                               ; b
                               ; space (ph - ph/2) bw |]

\emph{(** Stacks an array of boxes horizontally. *)}
\b{and} hconcat ?(align:vertical = `Center) boxes =\label{ref-hconcat}
    Array.fold_left (beside ~align) empty boxes

\emph{(** Stacks an array of boxes vertically. *)}
\b{and} vconcat ?(align:horizontal = `Center) boxes =\label{ref-vconcat}
    Array.fold_left (above ~align) empty boxes
\end{code}
\end{figure}

The \href{#ref-grid}{\code{grid}} function takes a \textsc{2-d} array of boxes,
combines each row horizontally,
and then combines results vertically.

\begin{code}[ocaml]
\emph{(** Combine a 2-d array of boxes. *)}
\b{let} grid g = Array.map hconcat g |> vconcat\label{ref-grid}
\end{code}

\code{grid}'s purpose is to save keystrokes.
The \code{framed} combinator draws a frame around its input
without spelling \code{hconcat} thrice.

\begin{code}[ocaml]
\b{let} framed b =
    let h, w = dimensions b in
    let vbar = fill '|' h 1 in
    let hbar = fill '-' 1 w in
    let corner = of_char '+' in
    grid [| [| corner; hbar; corner |]
          ; [| vbar;   b;    vbar   |]
          ; [| corner; hbar; corner |] |]
\end{code}

\section{examples}{Examples}
\subsection{sierpinski-triangle}{Sierpinski triangle}

Box combinators are a powerful tool for playing with fractals.
Rendering a \href{https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle}{Sierpinski triangle} requires only a few lines of code.

\begin{figure}
\marginnote{mn-sierpinski-code}{
A program drawing a Sierpinski triangle of order \code{n}.
}
\begin{code}[ocaml]
\b{let rec} sierpinski n =
    if n == 0 then Box.of_char '*'
    else let s = sierpinski (n - 1) in
         Box.above s (Box.hconcat [| s; Box.of_char ' '; s |])
\end{code}
\end{figure}

\begin{figure}
\marginnote{mn-sierpinski-rendered}{
A Sierpinski triangle rendered using box combinators.
}
\begin{code}[text]
\$ sierpinski 5 |> Box.print_box

                               *
                              * *
                             *   *
                            * * * *
                           *       *
                          * *     * *
                         *   *   *   *
                        * * * * * * * *
                       *               *
                      * *             * *
                     *   *           *   *
                    * * * *         * * * *
                   *       *       *       *
                  * *     * *     * *     * *
                 *   *   *   *   *   *   *   *
                * * * * * * * * * * * * * * * *
               *                               *
              * *                             * *
             *   *                           *   *
            * * * *                         * * * *
           *       *                       *       *
          * *     * *                     * *     * *
         *   *   *   *                   *   *   *   *
        * * * * * * * *                 * * * * * * * *
       *               *               *               *
      * *             * *             * *             * *
     *   *           *   *           *   *           *   *
    * * * *         * * * *         * * * *         * * * *
   *       *       *       *       *       *       *       *
  * *     * *     * *     * *     * *     * *     * *     * *
 *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
\end{code}
\end{figure}

\subsection{spiral}{Spiral}

The following snippet is a modified version of the spiral renderer from section 10.15 of ``\href{https://www.goodreads.com/book/show/5680904-programming-in-scala}{Programming in Scala}.''

\begin{figure}
\marginnote{mn-spiral-code}{
  A program drawing a spiral with \code{n} turns.
}
\begin{code}[ocaml]
\b{let rec} spiral n =
    let open Box in
    if n <= 0
    then of_char '+'
    else let s = spiral (n - 1) in
         let h, w = dimensions s in
         let vbar = fill '|' h 1 in
         grid [| [| of_string "| +"; fill '-' 1 w; of_char '+' |]
               ; [| vbar; of_char ' '; s; of_char ' '; vbar |]
               ; [| of_char '+'; fill '-' 1 (w+2); of_char '+' |] |]
\end{code}
\end{figure}

\begin{code}[text]
\$ spiral 4 |> Box.print_box

| +-------------+
| | +---------+ |
| | | +-----+ | |
| | | | +-+ | | |
| | | | + | | | |
| | | +---+ | | |
| | +-------+ | |
| +-----------+ |
+---------------+
\end{code}

\subsection{table}{Data table}

Playing with fractals is fun, but it won't pay our bills.
Business loves tables, and box combinators are a powerful tool for rendering them.
Let's display an array of book metadata in a human-friendly way.

\begin{code}[ocaml]
\b{type} book = { title : string;
              author : string;
              rating : int;
              price : float }

\b{let} books = [| { title = "Waiting for Good Dough";
                 author = "Samuel Biscuit";
                 rating = 4;
                 price = 23.86 };
               { title = "The Bun Also Rises";
                 author = "Ernest Hemingwaffle";
                 rating = 5;
                 price = 9.86 };
               { title = "Yeast of Eden";
                 author = "John Sconebeck";
                 rating = 2;
                 price = 6.00 };
               { title = "One Hundred Years of Solid Food";
                 author = "G. Gordita Marquez";
                 rating = 4;
                 price = 17.00 }
             |]
\end{code}

The \href{#ref-make-table}{\code{make_table}} function transforms records into a table in three steps:
\begin{enumerate}
\item Convert each field into a text box and stack related fields vertically, aligning them according to their data type (lines 6--9).
\item Place a column header above each of the resulting columns (lines 11--15).
\item Put vertical bars around the titled column boxes (line 17).
\end{enumerate}

\begin{code}[ocaml,linenumbers]
\b{let} make_table t =\label{ref-make-table}
    let open Box in
    let make_column f align =
        Array.map (fun b -> f b |> of_string) t |> vconcat ~align in
    let cols = [|
        ("Title",  make_column (fun b -> b.title) `Left);
        ("Author", make_column (fun b -> b.author) `Left);
        ("Rating", make_column (fun b -> String.make (b.rating) '*') `Left);
        ("Price",  make_column (fun b -> Printf.sprintf "\%.2f" b.price) `Right);
    |] in
    let titled = Array.map (fun (h, column) ->
        let header = of_string h in
        let hbar = fill '-' 1 (max (width header) (width column) + 2)
        in vconcat [| header; hbar; column |]
    ) cols in
    let vbar = fill '|' (height titled.(0)) 1 in
    Array.fold_left (fun acc col -> hconcat [| acc; col; vbar |]) vbar titled
\end{code}

Rendering the book metadata results in a neat \textsc{ascii} table.

\begin{figure}
\marginnote{mn-rendered-table}{
  Rendered book metadata array.
}
\begin{code}[text]
\$ make_table books |> Box.print_box

|              Title              |       Author        | Rating | Price |
|---------------------------------|---------------------|--------|-------|
| Waiting for Good Dough          | Samuel Biscuit      | ****   | 23.86 |
| The Bun Also Rises              | Ernest Hemingwaffle | *****  |  9.86 |
| Yeast of Eden                   | John Sconebeck      | **     |  6.00 |
| One Hundred Years of Solid Food | G. Gordita Marquez  | ****   | 17.00 |
\end{code}
\end{figure}

\section{conclusion}{Conclusion}

This text box implementation is not the most efficient since combining boxes in a loop has quadratic complexity.
A more sophisticated design would combine boxes lazily, delaying concatenations until the last moment or avoiding them entirely.
However, the simple approach is good enough for data that fits on a screen.

Each combinator library is a gem\sidenote{sn-pearl}{
  Or rather a \href{https://wiki.haskell.org/Research_papers/Functional_pearls}{functional pearl}.
} of ingenuity:
it's like a mathematical formulation that reduces a complex domain to a few simple types and operators.
Here are some of my favorite libraries:

\begin{itemize}
\item
Both ``\href{https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-15.html#%25_sec_2.2.4}{Structure and Interpretation of Computer Programs}''
and ``\href{https://www.goodreads.com/book/show/53001511-algebra-driven-design}{Algebra-Driven Design}''
(chapter 2) describe a combinator-based approach to constructing images.
The \href{https://diagrams.github.io/}{diagrams} package takes these ideas to the next level.
\item
\href{https://hackage.haskell.org/package/parsec}{Parsec} is a parser combinator library
that transforms writing simple parsers from a Herculean task into a fun game\sidenote{sn-parsec-hard}{
  Writing production-quality resilient parsers is hard even with the best libraries.
  Reporting meaningful error messages and recovering from parse errors is a high art.
}.
The \href{https://book.realworldhaskell.org/read/using-parsec.html}{Real World Haskell} book dedicates a chapter to this library.
\item
\href{https://www.microsoft.com/en-us/research/wp-content/uploads/2004/01/picklercombinators.pdf}{Pickler combinators} extend the parser idea onto the domain of binary serialization,
pairing encoding and decoding functions into a single primitive.
\item
The \href{https://hackage.haskell.org/package/prettyprinter-1.7.1/docs/Prettyprinter.html}{\code{prettyprinter}}
library provides combinators for laying out text under constraints,
for example, formatting code or error messages on a terminal screen.
\item
The \href{https://hackage.haskell.org/package/pipes-4.3.16/docs/Pipes-Tutorial.html}{pipes}
library implements coroutines using stream processing combinators.
\end{itemize}

Finally, if you want to practice your newly acquired tool,
implement it in your preferred language and use it to display complex information.
If you have no good ideas, \href{https://wiki.dlang.org/Component_programming_with_ranges#Case_Study:_Formatting_a_Calendar}{formatting a calendar}
will stretch your box-welding skills.

\end{document}

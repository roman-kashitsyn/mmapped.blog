\documentclass{article}

\title{The plan-execute pattern}
\subtitle{A ubiquitous pattern you won't find in your textbook.}
\date{2024-06-20}
\modified{2024-06-20}
\keyword{programming}

\begin{document}
\section*
I feel uneasy about design patterns.
On the one hand, my university class on design patterns revived my interest in programming.
On the other hand, I find most patterns in the \href{https://www.goodreads.com/book/show/85009.Design_Patterns}{Gang of Four book} to be irrelevant to my daily work; most of them don't solve real problems but rather problems that the programming language or paradigm creates.

My litmus test of a good design pattern is its cross-disciplinary applicability.
And the most convincing patterns are the ones that appear in my daily life.

This article describes one of the most ubiquitous and helpful patterns software engineers rarely discuss: the plan-execute pattern.

\section{motivation}{The motivation}

Imagine traveling from Washington, \sc{dc}, to New York City (from Vienna to Prague, from Zurich to Munich, etc.).
One approach is getting in your car, driving, following the road signs, and stopping at gas stations when needed.
I call this approach ``just do it.''
Another approach is to sit down with a map or a navigation app and plan your trip, deciding which paths to take and where to stop in advance.

I'm sure most people prefer the latter approach.
Yet, we often take the ``just do it'' path in software engineering.

The first time I applied this pattern was during my work on the \href{/posts/02-ic-state-machine-replication.html#incremental-sync}{incremental state synchronization protocol} at \sc{dfinity}.
The protocol brings a stale replica up to date: it takes the current replica state and the target state descriptions and reconstructs the target state checkpoint on disk.

The major problem with the protocol is testing.
The protocol is a black box that takes inputs and outputs the final state; how do I know it took the most efficient path to reconstruct the checkpoint?
All correct checkpoints are the same.

The solution I came up with was to factor the implementation into stages.
First, the implementation will acquire all the information required to reach its goal: the data structures describing the local and target states.
Next, the protocol builds a plan: a data structure encapsulating all the decisions the protocol will take: what data to fetch, what to copy from the existing state, and where to place all those pieces.
The last stage is the plan execution: the protocol fetches data from peers and applies disk writes according to the plan.

The planning phase was the most challenging part, and factoring it into a separate pure function made testing it a breeze.

\section{problem}{The problem}

We are now ready to define the problem when the pattern can be beneficial:
Given a complex algorithm that can take many paths to reach its goal, we want to ensure it takes the expected path.

\section{solution}{The solution}

The solution is to split the algorithm into two parts.
The planning phase takes the inputs and outputs a \emph{plan}: a data structure encapsulating all the decisions the algorithm will take.

\section{examples}{Examples}

\begin{itemize}
    \item \sc{rdbms} query execution.
    \item Bazel build planner.
    \item TensorFlow computation graph execution.
    \item The pattern is a special case of the ``functional core, imperative shell'' paradigm\sidenote{sn-functional-core}{
      I couldn't find an authoritative source explaining this paradigm, but \href{https://www.destroyallsoftware.com/talks/boundaries}{Gary Bernhardt's talk} is a good start.
    }.
    See also: \href{https://sans-io.readthedocs.io/how-to-sans-io.html}{Sans-I/O} protocol implementations.
    \item Programming in general.
    ``Programming'' was a synonym of ``planning'' before computers conquered the world.
    Programs \emph{are} plans: a programmer takes care of all the decisions in advance, leaving it to the computer to execute them.
\end{itemize}

\end{document}
